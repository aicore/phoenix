### Import :
```js
const StringMatch = brackets.getModule("utils/StringMatch")
```

<a name="SearchResult"></a>

## SearchResult()
Object representing a search result with associated metadata (added as extra ad hoc fields)

**Kind**: global function  
<a name="_computeRangesAndScore"></a>

## \_computeRangesAndScore(matchList, original, character) ⇒ <code>Object</code>
Converts a list of matches into a form suitable for returning from stringMatch.

**Kind**: global function  
**Returns**: <code>Object</code> - matched ranges and score  

| Param | Type | Description |
| --- | --- | --- |
| matchList | <code>Array.&lt;(SpecialMatch\|NormalMatch)&gt;</code> | to convert |
| original | <code>string</code> | string |
| character | <code>int</code> | index where last segment begins |

<a name="_codeHintsRelevanceSort"></a>

## \_codeHintsRelevanceSort(result, query, [prefixListLower], [maxResults], onlyContiguous) ⇒ <code>Array</code> \| <code>\*</code>
Computes the most relevant ordering for code hints.

**Kind**: global function  
**Returns**: <code>Array</code> \| <code>\*</code> - - The ordered results.  

| Param | Type | Description |
| --- | --- | --- |
| result | <code>Array</code> | The array of results to be ordered. |
| query | <code>string</code> | The query string used for matching. |
| [prefixListLower] | <code>Array.&lt;string&gt;</code> | Optional array of result values,          that will rank matching items in the choices to the top          if the query starts with the array. For example, on typing 'b', we have to show          'background-color' at the top. So we pass in ["background-color"] as a boost prefix list option           along with other CSS properties that we want to boost in the results. |
| [maxResults] | <code>number</code> | Optional maximum number of results to include in the output. |
| onlyContiguous | <code>boolean</code> | If set, will only include contiguous results. |

<a name="multiFieldSort"></a>

## multiFieldSort(searchResults, fieldSpec)
Sorts an array of SearchResult objects on a primary field, followed by secondary fieldsin case of ties. 'fieldSpec' provides the priority order for fields, where the first entry is the primary field, for example:     multiFieldSort(bugList, [ "milestone", "severity" ]);Would sort a bug list by milestone, and within each milestone sort bugs by severity.fieldSpec can also include comparator functions of the form normally used by the sort()function.Any fields that have a string value are compared case-insensitively. Fields used should bepresent on all SearchResult objects (no optional/undefined fields).

**Kind**: global function  

| Param | Type |
| --- | --- |
| searchResults | [<code>Array.&lt;SearchResult&gt;</code>](#SearchResult) | 
| fieldSpec | <code>Array.&lt;string, function()&gt;</code> | 

<a name="basicMatchSort"></a>

## basicMatchSort()
Sorts search results generated by stringMatch(): results are sorted into severaltiers based on how well they matched the search query, then sorted alphabeticallywithin each tier.

**Kind**: global function  
<a name="codeHintsSort"></a>

## codeHintsSort(query, choices, [options]) ⇒ <code>Array.&lt;string&gt;</code>
Retrieves the matching code hints based on the given query and choices array.

**Kind**: global function  
**Returns**: <code>Array.&lt;string&gt;</code> - - An array of matching code hints.  

| Param | Type | Description |
| --- | --- | --- |
| query | <code>string</code> | The search query to match against choices. |
| choices | <code>Array.&lt;string&gt;</code> | The list of possible code hints. |
| [options] | <code>object</code> | An optional object to specify additional search options. |
| options.limit | <code>number</code> | Maximum number of results to return |
| options.boostPrefixList | <code>Array.&lt;string&gt;</code> | Optional, Will rank matching items in the choices to top          if query starts with the array. EG: on typing b, we have to show background-color          to top. So we pass in ["background-color"] as boost prefix option along with other          css properties that we want to boost. |
| options.onlyContiguous | <code>boolean</code> | is set, will only include contiguous results. |

<a name="StringMatcher"></a>

## StringMatcher(options)
A StringMatcher provides an interface to the stringMatch function with built-incaching. You should use a StringMatcher for the lifetime of queries over asingle data set.You are free to store other data on this object to assist in higher-level caching.(This object's caches are all stored in "_" prefixed properties.)

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| options | <code>Object</code> | to control search behavior.                  preferPrefixMatches puts an exact case-insensitive prefix match ahead of all other matches,                  even short-circuiting the match logic. This option implies segmentedSearch=false.                  segmentedSearch treats segments of the string specially. |


* [StringMatcher(options)](#StringMatcher)
    * [._specialsCache](#StringMatcher+_specialsCache) : <code>Object</code>
    * [._noMatchCache](#StringMatcher+_noMatchCache) : <code>Object</code>
    * [.reset()](#StringMatcher+reset)
    * [.match(str, query)](#StringMatcher+match) ⇒ <code>Object</code>

<a name="StringMatcher+_specialsCache"></a>

### stringMatcher.\_specialsCache : <code>Object</code>
Map from search-result string to the findSpecialCharacters() result for that string - easy to cachesince this info doesn't change as the query changes.

**Kind**: instance property of [<code>StringMatcher</code>](#StringMatcher)  
<a name="StringMatcher+_noMatchCache"></a>

### stringMatcher.\_noMatchCache : <code>Object</code>
Set of search-result strings that we know don't match the query _lastQuery - or any other query withthat prefix.

**Kind**: instance property of [<code>StringMatcher</code>](#StringMatcher)  
<a name="StringMatcher+reset"></a>

### stringMatcher.reset()
Clears the caches. Use this in the event that the caches may be invalid.

**Kind**: instance method of [<code>StringMatcher</code>](#StringMatcher)  
<a name="StringMatcher+match"></a>

### stringMatcher.match(str, query) ⇒ <code>Object</code>
Performs a single match using the stringMatch function. See stringMatch for full documentation.

**Kind**: instance method of [<code>StringMatcher</code>](#StringMatcher)  
**Returns**: <code>Object</code> - matched ranges and score  

| Param | Type | Description |
| --- | --- | --- |
| str | <code>string</code> | The string to search |
| query | <code>string</code> | The query string to find in string |

